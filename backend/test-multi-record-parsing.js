const GalileoskyParser = require('./src/services/parser');
const logger = require('./src/utils/logger');

// Test data for 0x10-based format (records start with Archive Record Number)
const testData0x10Based = Buffer.from([
    // Header: 0x01 (Main Packet)
    0x01,
    // Length: 0x40 0x0B (2880 bytes, little endian)
    0x40, 0x0B,
    
    // Record 1: starts with 0x10 (Archive Record Number)
    0x10, 0x01, 0x00,  // Archive Record Number: 1
    0x20, 0x7E, 0x78, 0x68, 0x21,  // Date Time
    0x05, 0x00, 0x30, 0x10, 0xD7, 0x05, 0xA1, 0xFF, 0xB7, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x00, 0x00, 0x34, 0x2C, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x38, 0x00, 0x42, 0x6D, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // Record 2: starts with 0x10 (Archive Record Number)
    0x10, 0x02, 0x00,  // Archive Record Number: 2
    0x20, 0x7D, 0x78, 0x68, 0x21,  // Date Time
    0xF3, 0x00, 0x30, 0x0E, 0xB2, 0x07, 0xA1, 0xFF, 0x9D, 0x92, 0x5B, 0x06, 0x33, 0x2C, 0x00, 0x00, 0x00, 0x34, 0x24, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x3B, 0x00, 0x42, 0x8A, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // Record 3: starts with 0x10 (Archive Record Number)
    0x10, 0x03, 0x00,  // Archive Record Number: 3
    0x20, 0x3D, 0x78, 0x68, 0x21,  // Date Time
    0xB5, 0x02, 0x30, 0x0F, 0xCD, 0x07, 0xA1, 0xFF, 0xB6, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x51, 0x03, 0x34, 0x1F, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x3D, 0x22, 0x42, 0xDE, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // CRC (placeholder)
    0x00, 0x00
]);

// Test data for 0x20-based format (records start directly with Date Time)
const testData0x20Based = Buffer.from([
    // Header: 0x01 (Main Packet)
    0x01,
    // Length: 0x40 0x0B (2880 bytes, little endian)
    0x40, 0x0B,
    
    // Record 1: starts directly with 0x20 (Date Time)
    0x20, 0xF5, 0x7E, 0x78, 0x68, 0x21,  // Date Time
    0x05, 0x00, 0x30, 0x10, 0xD7, 0x05, 0xA1, 0xFF, 0xB7, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x00, 0x00, 0x34, 0x2C, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x38, 0x00, 0x42, 0x6D, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // Record 2: starts directly with 0x20 (Date Time)
    0x20, 0x7D, 0x7E, 0x78, 0x68, 0x21,  // Date Time
    0xF3, 0x00, 0x30, 0x0E, 0xB2, 0x07, 0xA1, 0xFF, 0x9D, 0x92, 0x5B, 0x06, 0x33, 0x2C, 0x00, 0x00, 0x00, 0x34, 0x24, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x3B, 0x00, 0x42, 0x8A, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // Record 3: starts directly with 0x20 (Date Time)
    0x20, 0x3D, 0x7E, 0x78, 0x68, 0x21,  // Date Time
    0xB5, 0x02, 0x30, 0x0F, 0xCD, 0x07, 0xA1, 0xFF, 0xB6, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x51, 0x03, 0x34, 0x1F, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x3D, 0x22, 0x42, 0xDE, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // CRC (placeholder)
    0x00, 0x00
]);

// Test data based on your actual hex data (0x20-based format)
const testDataRealExample = Buffer.from([
    // Header: 0x01 (Main Packet)
    0x01,
    // Length: 0x40 0x0B (2880 bytes, little endian)
    0x40, 0x0B,
    
    // Record 1: 20F57E78682105003010D705A1FFB7925B063300000000342C0040090B413800426D0D450F00460000500000510000520000E200000000E300000000
    0x20, 0xF5, 0x7E, 0x78, 0x68, 0x21, 0x05, 0x00, 0x30, 0x10, 0xD7, 0x05, 0xA1, 0xFF, 0xB7, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x00, 0x00, 0x34, 0x2C, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x38, 0x00, 0x42, 0x6D, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // Record 2: 207D7E786821F300300EB207A1FF9D925B06332C00000034240040090B413B00428A0D450F00460000500000510000520000E200000000E300000000
    0x20, 0x7D, 0x7E, 0x78, 0x68, 0x21, 0xF3, 0x00, 0x30, 0x0E, 0xB2, 0x07, 0xA1, 0xFF, 0x9D, 0x92, 0x5B, 0x06, 0x33, 0x2C, 0x00, 0x00, 0x00, 0x34, 0x24, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x3B, 0x00, 0x42, 0x8A, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // Record 3: 203D7E786821B502300FCD07A1FFB6925B063300005103341F0040090B413D2242DE0D450F00460000500000510000520000E200000000E300000000
    0x20, 0x3D, 0x7E, 0x78, 0x68, 0x21, 0xB5, 0x02, 0x30, 0x0F, 0xCD, 0x07, 0xA1, 0xFF, 0xB6, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x51, 0x03, 0x34, 0x1F, 0x00,
    0x40, 0x09, 0x0B, 0x41, 0x3D, 0x22, 0x42, 0xDE, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
    0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
    
    // CRC (placeholder)
    0x00, 0x00
]);

async function runTests() {
    console.log('=== Multi-Record Parsing Tests ===\n');
    
    const parser = new GalileoskyParser();
    const testConnection = '192.168.1.100:12345';
    
    // Test 1: 0x10-based format
    console.log('Test 1: 0x10-based format (records start with Archive Record Number)');
    console.log('=' .repeat(70));
    try {
        const result1 = await parser.parse(testData0x10Based, testConnection);
        console.log(`✅ Parsed ${result1.records.length} records`);
        console.log(`Expected: 3 records`);
        console.log(`Actual: ${result1.records.length} records`);
        
        if (result1.records.length === 3) {
            console.log('✅ Test 1 PASSED');
        } else {
            console.log('❌ Test 1 FAILED');
        }
        
        // Log details of each record
        result1.records.forEach((record, index) => {
            console.log(`Record ${index + 1}: ${Object.keys(record.tags).length} tags`);
            console.log(`  Tags: ${Object.keys(record.tags).join(', ')}`);
        });
        
    } catch (error) {
        console.log(`❌ Test 1 FAILED with error: ${error.message}`);
    }
    
    console.log('\n');
    
    // Test 2: 0x20-based format
    console.log('Test 2: 0x20-based format (records start directly with Date Time)');
    console.log('=' .repeat(70));
    try {
        const result2 = await parser.parse(testData0x20Based, testConnection);
        console.log(`✅ Parsed ${result2.records.length} records`);
        console.log(`Expected: 3 records`);
        console.log(`Actual: ${result2.records.length} records`);
        
        if (result2.records.length === 3) {
            console.log('✅ Test 2 PASSED');
        } else {
            console.log('❌ Test 2 FAILED');
        }
        
        // Log details of each record
        result2.records.forEach((record, index) => {
            console.log(`Record ${index + 1}: ${Object.keys(record.tags).length} tags`);
            console.log(`  Tags: ${Object.keys(record.tags).join(', ')}`);
        });
        
    } catch (error) {
        console.log(`❌ Test 2 FAILED with error: ${error.message}`);
    }
    
    console.log('\n');
    
    // Test 3: Real example data (0x20-based format)
    console.log('Test 3: Real example data (0x20-based format from your logs)');
    console.log('=' .repeat(70));
    try {
        const result3 = await parser.parse(testDataRealExample, testConnection);
        console.log(`✅ Parsed ${result3.records.length} records`);
        console.log(`Expected: 3 records`);
        console.log(`Actual: ${result3.records.length} records`);
        
        if (result3.records.length === 3) {
            console.log('✅ Test 3 PASSED');
        } else {
            console.log('❌ Test 3 FAILED');
        }
        
        // Log details of each record
        result3.records.forEach((record, index) => {
            console.log(`Record ${index + 1}: ${Object.keys(record.tags).length} tags`);
            console.log(`  Tags: ${Object.keys(record.tags).join(', ')}`);
            
            // Check for specific tags
            if (record.tags['0x20']) {
                console.log(`  DateTime: ${record.tags['0x20'].value}`);
            }
            if (record.tags['0x30']) {
                console.log(`  Coordinates: ${JSON.stringify(record.tags['0x30'].value)}`);
            }
        });
        
    } catch (error) {
        console.log(`❌ Test 3 FAILED with error: ${error.message}`);
    }
    
    console.log('\n');
    
    // Test 4: Single record test
    console.log('Test 4: Single record test');
    console.log('=' .repeat(70));
    
    const singleRecordData = Buffer.from([
        0x01, 0x20, 0x00,  // Header + Length (32 bytes)
        0x20, 0xF5, 0x7E, 0x78, 0x68, 0x21,  // Date Time
        0x05, 0x00, 0x30, 0x10, 0xD7, 0x05, 0xA1, 0xFF, 0xB7, 0x92, 0x5B, 0x06, 0x33, 0x00, 0x00, 0x00, 0x00, 0x34, 0x2C, 0x00,
        0x40, 0x09, 0x0B, 0x41, 0x38, 0x00, 0x42, 0x6D, 0x0D, 0x45, 0x0F, 0x00, 0x46, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00,
        0xE2, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00  // CRC
    ]);
    
    try {
        const result4 = await parser.parse(singleRecordData, testConnection);
        console.log(`✅ Parsed ${result4.records.length} records`);
        console.log(`Expected: 1 record`);
        console.log(`Actual: ${result4.records.length} records`);
        
        if (result4.records.length === 1) {
            console.log('✅ Test 4 PASSED');
        } else {
            console.log('❌ Test 4 FAILED');
        }
        
    } catch (error) {
        console.log(`❌ Test 4 FAILED with error: ${error.message}`);
    }
    
    console.log('\n=== Test Summary ===');
    console.log('These tests verify that the parser can handle:');
    console.log('1. Multi-record packets with 0x10-based format');
    console.log('2. Multi-record packets with 0x20-based format');
    console.log('3. Real example data from your logs');
    console.log('4. Single record packets');
    console.log('\nRun this test to verify the multi-record parsing fixes.');
}

// Run the tests
runTests().catch(error => {
    console.error('Test execution failed:', error);
    process.exit(1);
}); 